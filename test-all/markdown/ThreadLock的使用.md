ThreadLocal简介:ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。它采用采用空间来换取时间的方式，解决多线程中相同变量的访问冲突问题。ThreadLocal类提供如下几个核心方法：get()方法用于获取当前线程的副本变量值。set()方法用于保存当前线程的副本变量值。initialValue()为当前线程初始副本变量值。remove()方法移除当前前程的副本变量值。ThreadLocal的实现原理:每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。在该类中，我觉得最重要的方法就是两个：set()和get()方法。当调用ThreadLocal的get()方法的时候，会先找到当前线程的ThreadLocalMap，然后再找到对应的值。set()方法也是一样。在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了.Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。注意：因为Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，导致空余的内存无法被使用——发生了内存泄漏。所以每次使用了ThreadLocal后都要remove()在spring security 中存储用户信息的SecurityContextHolder的一个实现类就是采用ThreadLocal来实现的，感兴趣的可以去翻看资料。
